/*
Введение
- Цель лекции – показать, почему JavaScript-таймеры (например, setTimeout) могут быть неточными.
- Упомянута важность измерения производительности, особенно на бэкенде, но подробности будут опущены из-за ограниченности времени и обширности материала.

Измерение времени выполнения
- Для измерения используется performance.now(), функция, возвращающая количество миллисекунд с момента начала выполнения приложения.
- Пример использования performance.now() до и после setTimeout с задержкой в 1000 мс (1 секунда) демонстрирует, что фактическая задержка может быть больше запланированной.

Причины неточности
+ Event Loop: JavaScript-интерпретатор использует модель событийного цикла (event loop), влияющую на выполнение таймеров.
  - Когда таймер достигает своего времени, реальное выполнение может задержаться, так как event loop должен завершить текущее выполнение кода и проверить наличие других задач или событий перед выполнением задачи таймера.
  - Это означает, что setTimeout гарантирует задержку как минимум на указанное время, но фактическая задержка может быть больше в зависимости от загрузки event loop.
*/
